
# Javascript estrutura de dados e algoritmos 2 Ed.

https://github.com/loiane/javascript-datastructures-algorithms/

Meu resumo e Código fonte do livro **_Javascript Estrutura de Dados e Algoritmos Ed. 2_**. 

[Repositorio Oficcial - Loiane G.](https://github.com/loiane/javascript-datastructures-algorithms/) original do livro

## <a name="indice">Índice</a>

1. [Capítulo 01 JavaScript – uma visão geral rápida](#parte1)     
2. [Capítulo 02 Visão geral sobre ECMAScript e TypeScript](#parte2)     
3. [Capítulo 03 Arrays](#parte3)     
4. [Capítulo 04 Pilhas](#parte4)     
5. [Capítulo 05 Filas e deques](#parte5)     
6. [Capítulo 06 Listas ligadas](#parte6)     
7. [Capítulo 07 Conjuntos](#parte7)     
8. [Capítulo 08 Dicionários e hashes](#parte8)     
9. [Capítulo 09 Recursão](#parte9)     
10. [Capítulo 10 Árvores](#parte10)     
11. [Capítulo 11 Heap binário e heap sort](#parte11)     
12. [Capítulo 12 Grafos](#parte12)     
13. [Capítulo 13 Algoritmos de ordenação e de busca](#parte13)     
14. [Capítulo 14 Designs de algoritmos e técnicas](#parte14)     
15. [Capítulo 15 Complexidade de algoritmos](#parte15)     
---


## <a name="parte1">1 - Capítulo 01 JavaScript – uma visão geral rápida</a>

### - Estrutura de dados e algoritmos em JavaScript
### - Configurando o ambiente
### - Configuração mínima para trabalhar com JavaScript
### - Usando servidores web
### - http-server do Node.js
### - Básico sobre o JavaScript
### - Variáveis
### - Escopo das variáveis
### - Operadores
### - Verdadeiro e falso
### - Funções dos operadores de igualdade (== e ===)
### - Estruturas de controle
### - Instruções condicionais
### - Laços
### - Funções
### - Programação orientada a objetos em Javascript
### - Depuração e ferramentas
### - Depuração com o VSCode
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte2">2 - Capítulo 02 Visão geral sobre ECMAScript e TypeScript</a>

### - ECMAScript ou JavaScript?
### - ES6, ES2015, ES7, ES2016, ES8, ES2017 e ES.Next
### - Tabela de compatibilidade
### - Usando o Babel.js
### - Funcionalidades das versões ECMAScript 2015+
### - let e const no lugar de var
### - Escopo de variáveis com let e const
### - Templates literais
### - Funções de seta
### - Valores default para parâmetros de funções
### - Declarando os operadores de espalhamento e rest
### - Propriedades melhoradas de objetos
### - Programação orientada a objetos com classes
### - Herança
### - Trabalhando com getters e setters
### - Operador de exponencial
### - Módulos
### - Executando módulos ES2015 no navegador e com o Node.js
### - Usando importações nativas da ES2015 no Node.js
### - Executando módulos ES2015 no navegador
### - Compatibilidade de versões anteriores a ES2015+
### - Introdução ao TypeScript
### - Inferência de tipo
### - Interfaces
### - Genéricos
### - Outras funcionalidades do TypeScript
### - Verificações do TypeScript em tempo de compilação em arquivos JavaScript
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte3">3 - Capítulo 03 Arrays</a>

### - Por que devemos usar arrays?
### - Criando e inicializando arrays
### - Acessando elementos e fazendo uma iteração em um array
### - Acrescentando elementos
### - Inserindo um elemento no final do array
### - Usando o método push
### - Inserindo um elemento na primeira posição
### - Usando o método unshift
### - Removendo elementos
### - Removendo um elemento do final do array
### - Removendo um elemento da primeira posição
### - Usando o método shift
### - Adicionando e removendo elementos de uma posição específica
### - Arrays bidimensionais e multidimensionais
### - Iterando pelos elementos de arrays bidimensionais
### - Arrays multidimensionais
### - Referências para métodos de array em JavaScript
### - Juntando vários arrays
### - Funções de iteração
### - Iterando com o método every
### - Iterando com o método some
### - Iterando com forEach
### - Usando map e filter
### - Usando o método reduce
### - ECMAScript 6 e as novas funcionalidades de array
### - Iterando com o laço for…of
### - Usando o objeto @@iterator
### - Métodos entries, keys e values de array
### - Usando o método from
### - Usando o método Array.of
### - Usando o método fill
### - Usando o método copyWithin
### - Ordenando elementos
### - Ordenação personalizada
### - Ordenando strings
### - Pesquisa
### - ECMAScript 2015 – os métodos find e findIndex
### - ECMAScript 2016 – usando o método includes
### - Convertendo um array em uma string
### - Classe TypedArray
### - Arrays em TypeScript
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte4">4 - Capítulo 04 Pilhas</a>

### - Criação de uma biblioteca de estruturas de dados e algoritmos JavaScript
### - Estrutura de dados de pilha
### - Criando uma classe Stack baseada em array
### - Push de elementos na pilha
### - Pop de elementos da pilha
### - Dando uma espiada no elemento que está no topo da pilha
### - Verificando se a pilha está vazia
### - Limpando os elementos da pilha
### - Usando a classe Stack
### - Criando uma classe JavaScript Stack baseada em objeto
### - Push de elementos na pilha
### - Verificando se a pilha está vazia e o seu tamanho
### - Pop de elementos da pilha
### - Dando uma espiada no topo e limpando a pilha
### - Criando o método toString
### - Protegendo os elementos internos da estrutura de dados
### - Convenção de nomenclatura com underscore
### - Classes ES2015 com símbolos no escopo
### - Classes ES2015 com WeakMap
### - Proposta para campos de classe na ECMAScript
### - Resolvendo problemas usando pilhas
### - Convertendo números decimais para binários
### - Algoritmo conversor de base
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte5">5 - Capítulo 05 Filas e deques</a>

### - Estrutura de dados de fila
### - Criando a classe Queue
### - Inserção de elementos na fila
### - Remoção de elementos da fila
### - Dando uma espiada no elemento que está na frente da fila
### - Verificando se a pilha está vazia e o seu tamanho
### - Limpando a fila
### - Criando o método toString
### - Usando a classe Queue
### - Estrutura de dados de deque
### - Criando a classe Deque
### - Adicionando elementos na frente do deque
### - Usando a classe Deque
### - Resolvendo problemas usando filas e deques
### - Fila circular – Batata Quente
### - Verificador de palíndromo
### - Filas de tarefas em JavaScript
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte6">6 - Capítulo 06 Listas ligadas</a>

### - Estrutura de dados da lista ligada
### - Criando a classe LinkedList
### - Inserindo elementos no final da lista ligada
### - Removendo elementos de uma posição específica da lista ligada
### - Percorrendo a lista com um laço até alcançar a posição desejada
### - Refatorando o método remove
### - Inserindo um elemento em qualquer posição
### - Método indexOf: devolvendo a posição de um elemento
### - Removendo um elemento da lista ligada
### - Métodos isEmpty, size e getHead
### - Método toString
### - Listas duplamente ligadas
### - Inserindo um novo elemento em qualquer posição
### - Removendo elementos de qualquer posição
### - Listas ligadas circulares
### - Inserindo um novo elemento em qualquer posição
### - Removendo elementos de qualquer posição
### - Listas ligadas ordenadas
### - Inserindo elementos na ordem
### - Criando a classe StackLinkedList
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte7">7 - Capítulo 07 Conjuntos</a>

### - Estruturando um conjunto de dados
### - Criando uma classe Set
### - Método has(element)
### - Método add
### - Métodos delete e clear
### - Método size
### - Método values
### - Usando a classe Set
### - Operações em conjuntos
### - União de conjuntos
### - Intersecção de conjuntos
### - Aperfeiçoando o método intersection
### - Diferença entre conjuntos
### - Subconjunto
### - ECMAScript 2015 – a classe Set
### - Operações com a classe Set da ES2015
### - Simulando a operação de união
### - Simulando a operação de intersecção
### - Simulando a operação de diferença
### - Usando o operador de espalhamento
### - Multiconjuntos ou bags
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte8">8 - Capítulo 08 Dicionários e hashes</a>

### - Estrutura de dados de dicionário
### - Criando a classe Dictionary
### - Verificando se uma chave está presente no dicionário
### - Definindo uma chave e um valor no dicionário, e a classe ValuePair
### - Removendo um valor do dicionário
### - Obtendo um valor do dicionário
### - Métodos keys, values e valuePairs
### - Iterando pelos ValuePairs do dicionário com forEach
### - Métodos clear, size, isEmpty e toString
### - Usando a classe Dictionary
### - Tabela hash
### - Criando uma classe HashTable
### - Criando uma função de hash
### - Inserindo uma chave e um valor na tabela hash
### - Obtendo um valor da tabela hash
### - Removendo um valor da tabela hash
### - Usando a classe HashTable
### - Tabela hash versus conjunto hash
### - Tratando colisões nas tabelas hash
### - Encadeamento separado
### - Método put
### - Método get
### - Método remove
### - Sondagem linear
### - Método put
### - Método get
### - Método remove
### - Criando funções melhores de hash
### - Classe Map da ES2015
### - Classes WeakMap e WeakSet da ES2015
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte9">9 - Capítulo 09 Recursão</a>

### - Entendendo a recursão
### - Calculando o fatorial de um número
### - Fatorial iterativo
### - Fatorial recursivo
### - Pilha de chamadas
### - Limitação do tamanho da pilha de chamadas em JavaScript
### - Sequência de Fibonacci
### - Fibonacci iterativo
### - Fibonacci recursivo
### - Fibonacci com memoização
### - Por que usar recursão? É mais rápido?
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte10">10 - Capítulo 10 Árvores</a>

### - Estrutura de dados de árvore
### - Terminologia de árvores
### - Árvore binária e árvore binária de busca
### - Criando as classes Node e BinarySearchTree
### - Inserindo uma chave na BST
### - Percorrendo uma árvore
### - Percurso em-ordem
### - Percurso pré-ordem
### - Percurso pós-ordem
### - Pesquisando valores em uma árvore
### - Pesquisando valores mínimos e máximos
### - Pesquisando um valor específico
### - Removendo um nó
### - Removendo uma folha
### - Removendo um nó com um filho à esquerda ou à direita
### - Removendo um nó com dois filhos
### - Árvores autobalanceadas
### - Árvore de Adelson-Velskii e Landi (árvore AVL)
### - Altura de um nó e o fator de balanceamento
### - Operações de balanceamento – rotações na árvore AVL
### - Rotação Esquerda-Esquerda: rotação simples à direita
### - Rotação Direita-Direita: rotação simples à esquerda
### - Esquerda-Direita: rotação dupla à direita
### - Direita-Esquerda: rotação dupla à esquerda
### - Inserindo um nó na árvore AVL
### - Removendo um nó da árvore AVL
### - Árvore rubro-negra
### - Inserindo um nó na árvore rubro-negra
### - Verificando as propriedades da árvore rubro-negra após a inserção
### - Rotações na árvore rubro-negra
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte11">11 - Capítulo 11 Heap binário e heap sort</a>

### - Estrutura de dados do heap binário
### - Criando a classe MinHeap
### - Representação da árvore binária com um array
### - Inserindo um valor no heap
### - Operação de sift up
### - Encontrando os valores mínimo e máximo no heap
### - Extraindo os valores mínimo e máximo do heap
### - Operação de sift down
### - Criando a classe MaxHeap
### - Algoritmo de heap sort
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte12">12 - Capítulo 12 Grafos</a>

### - Terminologia dos grafos
### - Grafos direcionados e não direcionados
### - Representando um grafo
### - A matriz de adjacências
### - Lista de adjacências
### - Matriz de incidências
### - Criando a classe Graph
### - Percorrendo grafos
### - Busca em largura (BFS)
### - Encontrando os caminhos mais curtos usando BFS
### - Estudos adicionais sobre algoritmos de caminhos mais curtos
### - Busca em profundidade (DFS)
### - Explorando o algoritmo DFS
### - Ordenação topológica usando DFS
### - Algoritmos de caminho mais curto
### - Algoritmo de Dijkstra
### - Algoritmo de Floyd-Warshall
### - Árvore de extensão mínima (MST)
### - Algoritmo de Prim
### - Algoritmo de Kruskal
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte13">13 - Capítulo 13 Algoritmos de ordenação e de busca</a>

### - Algoritmos de ordenação
### - Bubble sort
### - Bubble sort melhorado
### - Selection sort
### - Insertion sort
### - Merge sort
### - Quick sort
### - Processo de partição
### - Quick sort em ação
### - Counting sort
### - Bucket sort
### - Radix sort
### - Algoritmos de busca
### - Busca sequencial
### - Busca binária
### - Busca por interpolação
### - Algoritmos de embaralhamento
### - Algoritmo de embaralhamento de Fisher-Yates
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte14">14 - Capítulo 14 Designs de algoritmos e técnicas</a>

### - Dividir e conquistar
### - Busca binária
### - Programação dinâmica
### - Problema do número mínimo de moedas para troco
### - Problema da mochila
### - Maior subsequência comum
### - Multiplicação de cadeia de matrizes
### - Algoritmos gulosos
### - Problema do número mínimo de moedas para troco
### - Problema fracionário da mochila
### - Algoritmos de backtracking
### - Rato em um labirinto
### - Solucionador de sudoku
### - Introdução à programação funcional
### - Programação funcional versus programação imperativa
### - ES2015+ e a programação funcional
### - Caixa de ferramentas funcional de JavaScript – map, filter e reduce
### - Bibliotecas e estruturas de dados funcionais de JavaScript
### - Resumo

[Voltar ao Índice](#indice)

---


## <a name="parte15">15 - Capítulo 15 Complexidade de algoritmos</a>

### - Notação big-O
### - Compreendendo a notação big-O
### - O(1)
### - O(n)
### - O(n2)
### - Comparando as complexidades
### - Estruturas de dados
### - Grafos
### - Algoritmos de ordenação
### - Algoritmos de busca
### - Introdução à teoria de NP-completo
### - Problemas impossíveis e algoritmos heurísticos
### - Divertindo-se com algoritmos
### - Resumo


[Voltar ao Índice](#indice)

---

